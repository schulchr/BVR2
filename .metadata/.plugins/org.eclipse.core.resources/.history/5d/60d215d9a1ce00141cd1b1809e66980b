package com.example.bvr;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.nio.ByteBuffer;

import android.opengl.GLES30;

public class GridState {
	/**
	 * The grid points from the GRID file
	 * and other information related to it
	 */
	static GridGridpoint[] gridPoints;
	static int gridWidth, gridHeight, gridDepth;
	static int gridTexWidth, gridTexHeight, gridTexDepth;
	static GridDataCamera gridCamera;
	static int loadedTextures[];
	static int loadedPoint;
	
	
	//
    // Read in the GRID file to populate the grid points 
    //
    public static void readGridFile(String mFileName)
    {
        //Read in the .grid file for data information
        try {
			File file = new File(mFilename);
			FileReader fileReader = new FileReader(file);
			BufferedReader bufferedReader = new BufferedReader(fileReader);
			StringBuffer stringBuffer = new StringBuffer();
			String line;
			
			//grab the dimensions of the grid. 
			line = bufferedReader.readLine();
			String[] split = line.split(" ");			
			gridWidth = Integer.parseInt(split[1]);
			
			line = bufferedReader.readLine();
			split = line.split(" ");			
			gridHeight = Integer.parseInt(split[1]);
			
			line = bufferedReader.readLine();
			split = line.split(" ");			
			gridDepth = Integer.parseInt(split[1]);
			
			//grab the dimensions each texture inside the grid. 
			line = bufferedReader.readLine();
			split = line.split(" ");			
			gridTexWidth = Integer.parseInt(split[1]);
			
			line = bufferedReader.readLine();
			split = line.split(" ");			
			gridTexHeight = Integer.parseInt(split[1]);
			
			line = bufferedReader.readLine();
			split = line.split(" ");			
			gridTexDepth = Integer.parseInt(split[1]);
			
			//setup the array for the number of gridpoints
			gridPoints = new GridGridpoint[gridWidth * gridHeight * gridDepth];
			
			int count = 0;
			while((line = bufferedReader.readLine()) != null){
				split = line.split(" "); 
				int i = 0;
				
				GridGridpoint point = new GridGridpoint();
				
				//grab the position of the grid point
				if(!split[i].startsWith("-"))
				{
					point.x = Float.parseFloat(split[i++]);
				}
				else
				{
					point.x = -Float.parseFloat(split[i++].substring(1));
				}
				
				if(!split[i].startsWith("-"))
				{
					point.y = Float.parseFloat(split[i++]);
				}
				else
				{
					point.y = -Float.parseFloat(split[i++].substring(1));
				}
				
				if(!split[i].startsWith("-"))
				{
					point.z = Float.parseFloat(split[i++]);
				}
				else
				{
					point.z = -Float.parseFloat(split[i++].substring(1));
				}
				
				//grab the textures related to the textures
				point.textures[GridConstants.BLL_TEX] = Integer.parseInt(split[i++]);
				point.textures[GridConstants.BLR_TEX] = Integer.parseInt(split[i++]);
				point.textures[GridConstants.BUL_TEX] = Integer.parseInt(split[i++]);
				point.textures[GridConstants.BUR_TEX] = Integer.parseInt(split[i++]);
				
				point.textures[GridConstants.TLL_TEX] = Integer.parseInt(split[i++]);
				point.textures[GridConstants.TLR_TEX] = Integer.parseInt(split[i++]);
				point.textures[GridConstants.TUL_TEX] = Integer.parseInt(split[i++]);
				point.textures[GridConstants.TUR_TEX] = Integer.parseInt(split[i++]);
				
				gridPoints[count++] = point;
			}
			
			fileReader.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
              
    }
    
    /**
     * This will loop through all the grid points and figure out which textures to use. 
     * Right now, this will just brute force the entire list of grid points. This can be optimized with the 
     */
    public void setGridTextures()
    {
    	gridCamera.updateViewVolume();
    	
    	for(int i = 0; i < gridPoints.length; i++)
    	{
    		
    		if(gridCamera.isInsideView(gridPoints[i]))
    		{
    			if(loadedPoint != i)
    			{
    				loadedPoint = i;
	    			loadGridTextures(gridPoints[i]);
    			}
    			return;
    		}
    		    			
    	}
    }
    
    public void loadGridTextures(GridGridpoint point)
    {
    	//Just to get this working, reload all the textures.
    	//If it causes lag, then we'll deal with only loading what's needed.
    	
    	for(int i = 0; i < 8; i++)
    	{
    		mAndroidDataHandle[i] = loadRaw(point.textures[i]);
    	}
    	    	
    }
    
    //
    // loads in the raw file
    //
    public static int loadRaw(int fileNum)
    {
        // Texture object handle
        int[] textureId = new int[1];             
                
        //Read in the .raw file (binary file)
        String filename = mFilename.substring(0, mFilename.length() - 5);
        filename = filename.concat("_");
        filename = filename.concat(Integer.toString(fileNum));
        filename = filename.concat(".raw");
        
        File file = new File(filename);
        byte[] result = new byte[(int)file.length()];
        try {
          InputStream input = null;
          try {
            int totalBytesRead = 0;
            input = new BufferedInputStream(new FileInputStream(file));
            while(totalBytesRead < result.length){
              int bytesRemaining = result.length - totalBytesRead;
              //input.read() returns -1, 0, or more :
              int bytesRead = input.read(result, totalBytesRead, bytesRemaining); 
              if (bytesRead > 0){
                totalBytesRead = totalBytesRead + bytesRead;
              }
            }
            
          }
          finally {
            input.close();
          }
        }
        catch (FileNotFoundException ex) {
        	
        }
        catch (IOException ex) {
        	
        }
        
        ByteBuffer pixelPad, pixelBuffer;
        int width, height, depth;
       
    	pixelBuffer = ByteBuffer.allocateDirect(result.length);
        pixelBuffer.put(result).position(0);
        width  = gridTexWidth;
        height = gridTexHeight;
        depth  = gridTexDepth;
        
        

        // Use tightly packed data
        GLES30.glPixelStorei ( GLES30.GL_UNPACK_ALIGNMENT, 1 );

        //  Generate a texture object
        GLES30.glGenTextures ( 1, textureId, 0 );
        
        
        // Bind the texture object
        GLES30.glBindTexture ( GLES30.GL_TEXTURE_3D, textureId[0] );        
        //  Load the texture
        GLES30.glTexImage3D ( GLES30.GL_TEXTURE_3D, 0, GLES30.GL_R8, width, height, depth, 0, GLES30.GL_RED, GLES30.GL_UNSIGNED_BYTE, pixelBuffer );

        // Set the filtering mode
        GLES30.glTexParameteri ( GLES30.GL_TEXTURE_3D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_NEAREST );
        GLES30.glTexParameteri ( GLES30.GL_TEXTURE_3D, GLES30.GL_TEXTURE_MAG_FILTER, GLES30.GL_NEAREST );
        
        return textureId[0];        
    }
}
